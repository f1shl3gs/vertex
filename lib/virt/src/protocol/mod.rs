mod auth;
mod connect_list_storage_pools;
mod constants;
mod domain_get_block_io_tune;
mod domain_get_xml_desc;
mod domain_memory_stats;
mod get_all_domain_stats;
mod get_domain_info;
mod get_domain_vcpus;
mod get_lib_version;
mod get_version;
mod open;
mod primitives;
mod storage_pool_get_info;

use std::fmt::{Display, Formatter};
use std::io::{self, Read, Write};
use std::string::FromUtf8Error;

pub use auth::*;
pub use connect_list_storage_pools::*;
use constants::*;
pub use domain_get_block_io_tune::*;
pub use domain_get_xml_desc::*;
pub use domain_memory_stats::*;
pub use get_all_domain_stats::*;
pub use get_domain_info::*;
pub use get_domain_vcpus::*;
pub use get_lib_version::*;
pub use get_version::*;
pub use open::*;
pub use primitives::*;
pub use storage_pool_get_info::*;

pub trait Procedure {
    fn procedure() -> i32;
}

macro_rules! impl_procedure {
    ($ty:ty, $proc:ident) => {
        impl crate::protocol::Procedure for $ty {
            fn procedure() -> i32 {
                crate::protocol::$proc
            }
        }
    };
}

pub(crate) use impl_procedure;

pub type Result<T> = std::result::Result<T, Error>;

macro_rules! impl_write {
    ($method:ident, $ty:ty) => {
        fn $method(&mut self, n: $ty) -> io::Result<()> {
            let buf = n.to_be_bytes();
            self.write_all(&buf)
        }
    };
}

pub trait WriteExt: Write {
    impl_write!(write_u32, u32);
    impl_write!(write_i32, i32);
}

impl<T: Write> WriteExt for T {}

macro_rules! impl_read {
    ($method:ident, $ty:ty, $size:expr) => {
        fn $method(&mut self) -> io::Result<$ty> {
            let mut buf = [0u8; $size];
            self.read_exact(&mut buf)?;
            Ok(<$ty>::from_be_bytes(buf))
        }
    };
}

pub trait ReadExt: Read {
    fn read_u8(&mut self) -> io::Result<u8> {
        let mut buf = [0u8; 1];
        self.read_exact(&mut buf)?;
        Ok(buf[0])
    }

    fn read_f64(&mut self) -> io::Result<f64> {
        let n = self.read_u64()?;
        Ok(f64::from_bits(n))
    }

    impl_read!(read_i32, i32, 4);
    impl_read!(read_u32, u32, 4);
    impl_read!(read_u64, u64, 8);
    impl_read!(read_i64, i64, 8);
}

impl<T: Read> ReadExt for T {}

/// Basic packing trait.
///
/// This trait is used to implement XDR packing any Rust type into a
/// `Write` stream. It returns the number of bytes the encoding took.
///
/// This crate provides a number of implementations for all the basic
/// XDR types, and generated code will generally compose them to pack
/// structures, unions, etc.
///
/// Streams generated by `Pack` can be consumed by `Unpack`.
pub trait Pack<W>
where
    W: Write,
{
    fn pack(&self, w: &mut W) -> Result<usize>;
}

impl<W: Write> Pack<W> for u32 {
    fn pack(&self, w: &mut W) -> Result<usize> {
        w.write_u32(*self)?;
        Ok(4)
    }
}

impl<W: Write, T: Pack<W>> Pack<W> for [T] {
    fn pack(&self, w: &mut W) -> Result<usize> {
        let len = self.len();
        let mut sz = (len as u32).pack(w)?;

        for it in self {
            sz += it.pack(w)?;
        }

        let p = padding(sz);
        if !p.is_empty() {
            w.write_all(p)?;
            sz += p.len();
        }

        Ok(sz)
    }
}

/// Basic unpacking trait
///
/// This trait is used to unpack a type from an XDR encoded byte
/// stream (encoded with `Pack`).  It returns the decoded instance and
/// the number of bytes consumed from the input.
///
/// This crate provides implementations for all the basic XDR types,
/// as well as for arrays.
pub trait Unpack<R: Read>: Sized {
    fn unpack(r: &mut R) -> Result<(Self, usize)>;
}

#[derive(Debug)]
pub enum Error {
    Io(io::Error),
    Utf8(FromUtf8Error),

    Other(String),

    InvalidCase(i32),
    InvalidEnum(i32),
    InvalidLen(usize),
}

impl Display for Error {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::Io(err) => err.fmt(f),
            Error::Utf8(err) => err.fmt(f),
            Error::Other(err) => err.fmt(f),
            Error::InvalidCase(c) => write!(f, "invalid case {}", c),
            Error::InvalidEnum(c) => write!(f, "invalid enum {}", c),
            Error::InvalidLen(len) => write!(f, "invalid len {}", len),
        }
    }
}

impl From<io::Error> for Error {
    fn from(value: io::Error) -> Self {
        Self::Io(value)
    }
}

impl From<FromUtf8Error> for Error {
    fn from(value: FromUtf8Error) -> Self {
        Self::Utf8(value)
    }
}

impl<R: Read> Unpack<R> for u32 {
    #[inline]
    fn unpack(r: &mut R) -> Result<(Self, usize)> {
        r.read_u32().map_err(Error::from).map(|v| (v, 4))
    }
}

impl<R: Read> Unpack<R> for usize {
    #[inline]
    fn unpack(r: &mut R) -> Result<(Self, usize)> {
        u32::unpack(r).map(|(v, sz)| (v as usize, sz))
    }
}

impl<R: Read, T: Unpack<R>> Unpack<R> for Option<T> {
    fn unpack(r: &mut R) -> Result<(Self, usize)> {
        match r.read_i32()? {
            0 => Ok((None, 4)),
            1 => {
                let (value, sz) = T::unpack(r)?;
                Ok((Some(value), sz + 4))
            }
            v => Err(Error::InvalidEnum(v)),
        }
    }
}

/// Pack a dynamically sized array, with size limit check.
///
/// This packs an array of packable objects, and also applies an optional size limit.
#[inline]
pub fn pack_flex<W: Write, T: Pack<W>>(
    val: &[T],
    max_size: Option<usize>,
    w: &mut W,
) -> Result<usize> {
    if max_size.map_or(false, |m| val.len() > m) {
        return Err(Error::InvalidLen(max_size.unwrap()));
    }

    val.pack(w)
}

/// Unpack a (perhaps) length-limited array
pub fn unpack_flex<R: Read, T: Unpack<R>>(r: &mut R, max_size: usize) -> Result<(Vec<T>, usize)> {
    let (elems, mut sz) = Unpack::unpack(r)?;

    if elems > max_size {
        return Err(Error::InvalidLen(max_size));
    }

    let mut out = Vec::with_capacity(elems);

    for _ in 0..elems {
        let (e, esz) = Unpack::unpack(r)?;
        out.push(e);
        sz += esz;
    }

    let p = padding(sz);
    for _ in 0..p.len() {
        let _ = r.read_u8()?;
    }
    sz += p.len();

    Ok((out, sz))
}

impl<R: Read, T: Unpack<R>> Unpack<R> for Vec<T> {
    fn unpack(input: &mut R) -> Result<(Self, usize)> {
        unpack_flex(input, u16::MAX as usize)
    }
}

#[cfg(test)]
pub fn assert_pack<P>(req: P, want: &[u8])
where
    P: for<'a> Pack<Vec<u8>> + Sized,
{
    let mut buf = Vec::new();
    req.pack(&mut buf).expect("encode success");

    assert_eq!(buf, want)
}
