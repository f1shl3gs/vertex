use std::collections::HashMap;
use std::fmt::Debug;
use std::marker::PhantomData;
use std::sync::{Mutex, MutexGuard, OnceLock};

use event::LogRecord;
use event::log::Value;
use event::trace::generator::IdGenerator;
use event::trace::{RngGenerator, Span, SpanId, TraceId};
use futures::{Stream, StreamExt, future::ready};
use tokio::sync::broadcast::{self, Receiver, Sender};
use tokio_stream::wrappers::BroadcastStream;
use tracing::span::Attributes;
use tracing::{Event, Id, Subscriber};
use tracing_core::Field;
use tracing_internal::PreSampledTracer;
use tracing_limit::RateLimitedLayer;
use tracing_subscriber::Layer;
use tracing_subscriber::layer::{Context, SubscriberExt};
use tracing_subscriber::registry::LookupSpan;
use tracing_subscriber::util::SubscriberInitExt;

/// BUFFER contains all of the internal log events generated by Vertex before
/// the topology has been initialized. It will be cleared (set to `None`) by
/// the topology initialization routines.
static BUFFER: Mutex<Option<Vec<LogRecord>>> = Mutex::new(Some(vec![]));

/// SENDER holds the sender/receiver handle that will received a copy of all the
/// internal log events *after* the topology has been initialized
static SENDER: OnceLock<Sender<LogRecord>> = OnceLock::new();

static SPAN_SENDER: OnceLock<Sender<Span>> = OnceLock::new();

/// A subscription to the log events flowing in via `tracing`, in the Vertex
/// native format.
///
/// Used to capture tracing events from internal log telemetry, via `tracing`,
/// and convert them to native Vertex events, specifically `LogRecord`, such
/// that they can be shuttled around and treated as normal events. Currently
/// only powers the `internal_logs` source, but could be used for other
/// purposes if need be.
pub struct TraceSubscription {
    receiver: Receiver<LogRecord>,
}

impl TraceSubscription {
    /// Registers a subscription to the internal log event stream.
    pub fn subscribe() -> TraceSubscription {
        let receiver = SENDER.get_or_init(|| broadcast::channel(100).0).subscribe();
        TraceSubscription { receiver }
    }

    /// Gets any early buffered log events.
    ///
    /// If this subscription was registered after early buffering was turned off, `None`
    /// will be returned immediately.
    pub fn buffered(&mut self) -> Vec<LogRecord> {
        match early_buffer().as_mut() {
            Some(buffer) => std::mem::take(buffer),
            None => vec![],
        }
    }

    /// Converts this subscription into a raw stream of log events.
    pub fn into_stream(self) -> impl Stream<Item = LogRecord> + Unpin {
        // We ignore errors because the only error we get is when the broadcast receiver
        // lags, and there's nothing we can actually do about that so there's no reason
        // to force callers to even deal with it.
        BroadcastStream::new(self.receiver).filter_map(|item| ready(item.ok()))
    }
}

pub struct SpanSubscription {
    pub receiver: Receiver<Span>,
}

impl SpanSubscription {
    pub fn subscribe() -> SpanSubscription {
        let receiver = SPAN_SENDER
            .get_or_init(|| broadcast::channel(100).0)
            .subscribe();

        SpanSubscription { receiver }
    }

    pub fn into_stream(self) -> impl Stream<Item = Span> + Unpin {
        BroadcastStream::new(self.receiver).filter_map(|item| ready(item.ok()))
    }
}

fn early_buffer() -> MutexGuard<'static, Option<Vec<LogRecord>>> {
    BUFFER
        .lock()
        .expect("Couldn't acquire lock on internal logs buffer")
}

#[cfg(any(test, feature = "test-util"))]
pub fn reset_early_buffer() {
    *early_buffer() = Some(vec![])
}

struct BroadcastLayer<S> {
    _subscriber: PhantomData<S>,
}

impl<S> BroadcastLayer<S> {
    const fn new() -> Self {
        BroadcastLayer {
            _subscriber: PhantomData,
        }
    }
}

impl<S> Layer<S> for BroadcastLayer<S>
where
    S: Subscriber + 'static + for<'lookup> LookupSpan<'lookup>,
{
    fn on_new_span(&self, attrs: &Attributes<'_>, id: &Id, ctx: Context<'_, S>) {
        let span = ctx.span(id).expect("span must already exist");
        let mut fields = SpanFields::default();
        attrs.values().record(&mut fields);
        span.extensions_mut().insert(fields);
    }

    fn on_event(&self, event: &Event<'_>, _ctx: Context<'_, S>) {
        if let Some(buffer) = early_buffer().as_mut() {
            buffer.push(event.into());
        }

        if let Some(sender) = SENDER.get() {
            // Ignore errors
            let _ = sender.send(event.into());
        }
    }
}

#[derive(Default, Debug)]
struct SpanFields(HashMap<&'static str, Value>);

impl SpanFields {
    fn record(&mut self, field: &Field, value: impl Into<Value>) {
        let name = field.name();

        // Filter for span fields such as component_id, component_type, etc.
        //
        // This captures all the basic component information provided in the
        // span that each component is spawned with. We don't capture all
        // fields to avoid adding unintentional noise and to prevent accidental
        // security/privacy issues (e.g. leaking sensitive data).
        if name.starts_with("component_") {
            self.0.insert(name, value.into());
        }
    }
}

impl tracing::field::Visit for SpanFields {
    fn record_i64(&mut self, field: &Field, value: i64) {
        self.record(field, value)
    }

    fn record_u64(&mut self, field: &Field, value: u64) {
        self.record(field, value)
    }

    fn record_bool(&mut self, field: &Field, value: bool) {
        self.record(field, value)
    }

    fn record_str(&mut self, field: &Field, value: &str) {
        self.record(field, value)
    }

    fn record_debug(&mut self, field: &Field, value: &dyn Debug) {
        self.record(field, format!("{:?}", value))
    }
}

#[derive(Default)]
struct InternalTracer {
    id_gen: RngGenerator,
}

impl PreSampledTracer for InternalTracer {
    fn export(&self, span: Span) {
        let sender = SPAN_SENDER.get_or_init(|| broadcast::channel(100).0);
        let _ = sender.send(span);
    }

    fn new_trace_id(&self) -> TraceId {
        self.id_gen.new_trace_id()
    }

    fn new_span_id(&self) -> SpanId {
        self.id_gen.new_span_id()
    }
}

pub fn init(color: bool, json: bool, levels: &str, internal_log_rate_limit: u64) {
    let broadcast_layer =
        RateLimitedLayer::new(BroadcastLayer::new()).with_default_limit(internal_log_rate_limit);

    let subscriber = tracing_subscriber::registry()
        .with(tracing_subscriber::filter::EnvFilter::from(levels))
        .with(broadcast_layer);

    #[cfg(feature = "tokio-console")]
    let subscriber = {
        let console_layer = console_subscriber::ConsoleLayer::builder()
            .with_default_env()
            .spawn();

        subscriber.with(console_layer)
    };

    if json {
        let formatter = tracing_subscriber::fmt::layer().json().flatten_event(true);

        #[cfg(test)]
        let formatter = formatter.with_test_writer();

        let rate_limited =
            RateLimitedLayer::new(formatter).with_default_limit(internal_log_rate_limit);
        let trace_layer = tracing_internal::TracingLayer::new(InternalTracer::default());
        let subscriber = subscriber.with(rate_limited).with(trace_layer);

        let _ = subscriber.try_init();
    } else {
        let formatter = tracing_subscriber::fmt::layer()
            .with_ansi(color)
            .with_writer(std::io::stderr);

        #[cfg(test)]
        let formatter = formatter.with_test_writer();

        let rate_limited =
            RateLimitedLayer::new(formatter).with_default_limit(internal_log_rate_limit);
        let trace_layer = tracing_internal::TracingLayer::new(InternalTracer::default());
        let subscriber = subscriber.with(rate_limited).with(trace_layer);

        let _ = subscriber.try_init();
    }
}

pub fn stop_buffering() {
    *early_buffer() = None;
}

#[cfg(any(test, feature = "test-util"))]
pub fn test_init() {
    use std::io::IsTerminal;

    #[cfg(unix)]
    let color = std::io::stdout().is_terminal();
    #[cfg(not(unix))]
    let color = false;

    let level = std::env::var("TEST_LOG").unwrap_or_else(|_| "error".to_string());

    init(color, false, &level, 10);
}
