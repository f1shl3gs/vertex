use std::collections::HashMap;
use std::fmt::Debug;
use std::marker::PhantomData;
use std::sync::{Mutex, MutexGuard};

use event::log::Value;
use event::trace::generator::IdGenerator;
use event::trace::{RngGenerator, Span, SpanId, TraceId};
use event::LogRecord;
use once_cell::sync::OnceCell;
use tokio::sync::broadcast::{self, Receiver, Sender};
use tracing::span::Attributes;
use tracing::{Event, Id, Subscriber};
use tracing_core::Field;
use tracing_internal::PreSampledTracer;
use tracing_limit::RateLimitedLayer;
use tracing_subscriber::layer::{Context, SubscriberExt};
use tracing_subscriber::registry::LookupSpan;
use tracing_subscriber::util::SubscriberInitExt;
use tracing_subscriber::Layer;

/// BUFFER contains all of the internal log events generated by Vertex before
/// the topology has been initialized. It will be cleared (set to `None`) by
/// the topology initialization routines.
static BUFFER: OnceCell<Mutex<Option<Vec<LogRecord>>>> = OnceCell::new();

/// SENDER holds the sender/receiver handle that will received a copy of all the
/// internal log events *after* the topology has been initialized
static SENDER: OnceCell<Sender<LogRecord>> = OnceCell::new();

static SPAN_SENDER: OnceCell<Sender<Span>> = OnceCell::new();

pub struct TraceSubscription {
    pub buffer: Vec<LogRecord>,
    pub receiver: Receiver<LogRecord>,
}

pub fn subscribe() -> TraceSubscription {
    let buffer = match early_buffer().as_mut() {
        Some(buffer) => buffer.drain(..).collect(),
        None => vec![],
    };

    let receiver = SENDER.get_or_init(|| broadcast::channel(100).0).subscribe();
    TraceSubscription { buffer, receiver }
}

pub struct SpanSubscription {
    pub receiver: Receiver<Span>,
}

pub fn subscribe_spans() -> SpanSubscription {
    let receiver = SPAN_SENDER
        .get_or_init(|| broadcast::channel(100).0)
        .subscribe();

    SpanSubscription { receiver }
}

fn early_buffer() -> MutexGuard<'static, Option<Vec<LogRecord>>> {
    BUFFER
        .get()
        .expect("Internal logs buffer not initialized")
        .lock()
        .expect("Couldn't acquire lock on internal logs buffer")
}

#[cfg(any(test, feature = "test-util"))]
pub fn reset_early_buffer() {
    *early_buffer() = Some(vec![])
}

struct BroadcastLayer<S> {
    _subscriber: PhantomData<S>,
}

impl<S> BroadcastLayer<S> {
    const fn new() -> Self {
        BroadcastLayer {
            _subscriber: PhantomData,
        }
    }
}

impl<S> Layer<S> for BroadcastLayer<S>
where
    S: Subscriber + 'static + for<'lookup> LookupSpan<'lookup>,
{
    fn on_new_span(&self, attrs: &Attributes<'_>, id: &Id, ctx: Context<'_, S>) {
        let span = ctx.span(id).expect("span must already exist");
        let mut fields = SpanFields::default();
        attrs.values().record(&mut fields);
        span.extensions_mut().insert(fields);
    }

    fn on_event(&self, event: &Event<'_>, _ctx: Context<'_, S>) {
        if let Some(buffer) = early_buffer().as_mut() {
            buffer.push(event.into());
        }

        if let Some(sender) = SENDER.get() {
            // Ignore errors
            let _ = sender.send(event.into());
        }
    }
}

#[derive(Default, Debug)]
struct SpanFields(HashMap<&'static str, Value>);

impl SpanFields {
    fn record(&mut self, field: &tracing_core::Field, value: impl Into<Value>) {
        let name = field.name();

        // Filter for span fields such as component_id, component_type, etc.
        //
        // This captures all the basic component information provided in the
        // span that each component is spawned with. We don't capture all
        // fields to avoid adding unintentional noise and to prevent accidental
        // security/privacy issues (e.g. leaking sensitive data).
        if name.starts_with("component_") {
            self.0.insert(name, value.into());
        }
    }
}

impl tracing::field::Visit for SpanFields {
    fn record_i64(&mut self, field: &Field, value: i64) {
        self.record(field, value)
    }

    fn record_u64(&mut self, field: &Field, value: u64) {
        self.record(field, value)
    }

    fn record_bool(&mut self, field: &Field, value: bool) {
        self.record(field, value)
    }

    fn record_str(&mut self, field: &Field, value: &str) {
        self.record(field, value)
    }

    fn record_debug(&mut self, field: &Field, value: &dyn Debug) {
        self.record(field, format!("{:?}", value))
    }
}

#[derive(Default)]
struct InternalTracer {
    gen: RngGenerator,
}

impl PreSampledTracer for InternalTracer {
    fn export(&self, span: Span) {
        let sender = SPAN_SENDER.get_or_init(|| broadcast::channel(100).0);
        let _ = sender.send(span);
    }

    fn new_trace_id(&self) -> TraceId {
        self.gen.new_trace_id()
    }

    fn new_span_id(&self) -> SpanId {
        self.gen.new_span_id()
    }
}

pub fn init(color: bool, json: bool, levels: &str, internal_log_rate_limit: u64) {
    let _ = BUFFER.set(Mutex::new(Some(vec![])));

    let broadcast_layer =
        RateLimitedLayer::new(BroadcastLayer::new()).with_default_limit(internal_log_rate_limit);

    let subscriber = tracing_subscriber::registry()
        .with(tracing_subscriber::filter::EnvFilter::from(levels))
        .with(broadcast_layer);

    #[cfg(feature = "tokio-console")]
    let subscriber = {
        let console_layer = console_subscriber::ConsoleLayer::builder()
            .with_default_env()
            .spawn();

        subscriber.with(console_layer)
    };

    if json {
        let formatter = tracing_subscriber::fmt::layer().json().flatten_event(true);

        #[cfg(test)]
        let formatter = formatter.with_test_writer();

        let rate_limited =
            RateLimitedLayer::new(formatter).with_default_limit(internal_log_rate_limit);
        let trace_layer = tracing_internal::TracingLayer::new(InternalTracer::default());
        let subscriber = subscriber.with(rate_limited).with(trace_layer);

        let _ = subscriber.try_init();
    } else {
        let formatter = tracing_subscriber::fmt::layer()
            .with_ansi(color)
            .with_writer(std::io::stderr);

        #[cfg(test)]
        let formatter = formatter.with_test_writer();

        let rate_limited =
            RateLimitedLayer::new(formatter).with_default_limit(internal_log_rate_limit);
        let trace_layer = tracing_internal::TracingLayer::new(InternalTracer::default());
        let subscriber = subscriber.with(rate_limited).with(trace_layer);

        let _ = subscriber.try_init();
    }
}

pub fn stop_buffering() {
    *early_buffer() = None;
}

#[cfg(any(test, feature = "test-util"))]
pub fn test_init() {
    #[cfg(unix)]
    let color = atty::is(atty::Stream::Stdout);
    #[cfg(not(unix))]
    let color = false;

    let level = std::env::var("TEST_LOG").unwrap_or_else(|_| "error".to_string());

    init(color, false, &level, 10);
}
